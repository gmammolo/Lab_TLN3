{
  "thread": {
    "uuid": "afdc9105d5aa5664458c8d86885f54ed53dc4fb0",
    "url": "https://www.meneame.net/story/rust-parecia-lenguaje-ideal-programar-videojuegos-este-estudio/c0360",
    "site_full": "www.meneame.net",
    "site": "meneame.net",
    "site_section": "https://www.meneame.net:443/comments_rss",
    "site_categories": [
      "media",
      "top_news_es",
      "top_news"
    ],
    "section_title": "Menéame: comentarios",
    "title": "#360 Rust parecía el lenguaje ideal para programar videojuegos. Este estudio acabó abandonándolo tras tres años centrados en él",
    "title_full": "#360 Rust parecía el lenguaje ideal para programar videojuegos. Este estudio acabó abandonándolo tras tres años centrados en él",
    "published": "2025-01-10T00:24:00.000+02:00",
    "replies_count": 0,
    "participants_count": 1,
    "site_type": "news",
    "country": "ES",
    "main_image": "https://www.meneame.net/backend/media?type=link&amp;id=4015153&amp;version=0&amp;ts=1735949346&amp;image.webp",
    "performance_score": 0,
    "domain_rank": 13272,
    "domain_rank_updated": "2025-01-06T23:00:00.000+02:00",
    "social": {
      "facebook": {
        "likes": 0,
        "comments": 0,
        "shares": 0
      },
      "vk": {
        "shares": 0
      }
    }
  },
  "uuid": "afdc9105d5aa5664458c8d86885f54ed53dc4fb0",
  "url": "https://www.meneame.net/story/rust-parecia-lenguaje-ideal-programar-videojuegos-este-estudio/c0360",
  "ord_in_thread": 0,
  "parent_url": null,
  "author": "repl_logos",
  "published": "2025-01-10T00:24:00.000+02:00",
  "title": "#360 Rust parecía el lenguaje ideal para programar videojuegos. Este estudio acabó abandonándolo tras tres años centrados en él",
  "text": "·\nmain action\n×\nedición general\nlogin\nregistrarse\ncomunidades\nfisgona\nnótame\ngalería\nayuda\npublicar\nCrear artículo\npublicaciones\nnuevas\nartículos\npopulares\nmás visitadas\nMÁS\ntodas\nactualidad\nciencia\ncultura\nocio\npolitica\ntecnología\nm/*\nRSS\nmás visitadas\n8688\nclics\nEsto es Malibú, uno de los lugares más ricos y opulentos de todo el planeta, ahora reducido a cenizas [Eng]\n9608\nclics\nVista aérea desde la ventana de un avión de la devastación que van causando los incendios sobre los Ángeles\n6552\nclics\nLos trucos mentales secretos de Ikea para que gastes más\n6031\nclics\n¿Qué puta mierda es un roscón sin whisky?\n5471\nclics\nMarcas de productos que pagan las balas del genocidio israelí\nmás votadas\n438\nEl Mundo Today anuncia que elimina sus protocolos de verificación de datos\n634\nLa OCU se lanza a publicitar alarmas para viviendas y negocios: una empresa le paga 121 euros de comisión por cada cliente que le capta\n651\nLa SER relata ante el Supremo que tuvo acceso al mail del novio de Ayuso 6 horas antes que el fiscal general del Estado\n653\nMujica anuncia la extensión del cáncer, que no seguirá con el tratamiento y pide morir \"tranquilo\"\n635\nRaffi Berg: El editor de la BBC para Oriente Medio es descubierto como colaborador de la CIA y el Mossad [ENG]\nsuscripciones por RSS\npublicadas\nen cola\ncomentarios de esta noticia\ntodos los comentarios\n139\nmeneos\nmenéalo\n1986\nclics\nRust parecía el lenguaje ideal para programar videojuegos. Este estudio acabó abandonándolo tras tres años centrados en él\npor\nCrudaVerdad\na\ngenbeta.com\n____\npublicado:\n____\nEl estudio de videojuegos LogLog Games se da por vencido con Rust, al que siguen viendo muchas ventajas... para todo lo que no sean videojuegos. Uno de los principales retos fue la curva de aprendizaje del lenguaje: Rust es notoriamente complicado para principiantes y, aunque los desarrolladores de LogLog Games no eran precisamente inexpertos (escribieron más de 100.000 líneas de código en esos tres años), muchos de los problemas iniciales no desaparecieron con el tiempo.\n|\netiquetas\n:\nrust\n,\nno sirve\n,\nvideojuegos\n68\n71\n3\nK\n450\ntecnología\n360 comentarios\ncompartir\nCompartir en Facebook\nCompartir en Twitter\nCompartir por Correo\nCopiar enlace\n68\n71\n3\nK\n450\ntecnología\nComentarios destacados:\n#44\n#38\nNo.\nC no es un ensamblador con colorines. Y te lo dice alguien que tiene los huevos pelados de programar en C y en su día en ensamblador.\nC proporciona un fácil acceso a ASM embebido, pero no es un \"ensamblador con colorines\". Basta que hayas tenido que escribir algún código en ensamblador para que te des cuenta.\nLo que ejecute la CPU cuando programamos en C preocupa más bien poco. Se encarga el compilador de ello. Igual que en Rust.\nordenados\nhilos\nmejores hilos\n+ valorados\nvotos\nregistros\nµ fisgona\nrelacionadas\n#44\nchavi\n#38\nNo.\nC no es un ensamblador con colorines. Y te lo dice alguien que tiene los huevos pelados de programar en C y en su día en ensamblador.\nC proporciona un fácil acceso a ASM embebido, pero no es un \"ensamblador con colorines\". Basta que hayas tenido que escribir algún código en ensamblador para que te des cuenta.\nLo que ejecute la CPU cuando programamos en C preocupa más bien poco. Se encarga el compilador de ello. Igual que en Rust.\n25\nK\n154\n#50\nrepl_logos\n#44\nMira el microcodigo de hoy con los procesadores y lo entenderas.\n3\nK\n34\n#56\nchavi\n#50\n¿ Qué coño tiene que ver el microcódigo de los procesadores con este tema ?\n¿ Sabes como funciona una CPU microprogramada ?\nEsa historia de la unidad de control, juego de instrucciones....\n¿ Te recomiendo un libro ?\n4\nK\n39\n#58\nrepl_logos\n#56\nTe recomiendo yo leerte\nen.wikipedia.org/wiki/Microcode\npara empezar.\n2\nK\n22\n#62\nchavi\n#58\nEl Microcódigo de las CPU no tiene absolutamente nada que ver en el tema que estamos tratando. Y sé perfectamente qué es, para qué sirve y en qué consiste.\nPor lo que se ve, tú no.\n11\nK\n78\n#202\nthe_fuck_right\n#62\n#58\nJoder! Tenía yo ganas de volver a ver discusiones por estas cosas y no por política!!\nUn abrazo a ambos\n9\nK\n73\n#204\nPortgasDAce\n*\n#58\ndeja de seguir insistiendo en algo que no tienes ni idea.\nC era ensamblador con colorines en su nacimiento, cuando las máquinas eran simples y era \"predecible\" el output del binario, en el sentido de que la gente se podía imaginar que set de órdenes de ensamblador equivalían a cada orden de C. Pero no permitía ir al detalle al que iba ensamblador, podríamos decir entre muchas comillas que era casi \"un macro\" de assembler.\nEso dejó de ser así hace muchísimo, para…\n» ver todo el comentario\n2\nK\n20\n#147\nElektr0\n#56\nQuiero el nombre de ese libro, por curiosidad, porque me gusta el mundo de la programación a bajo nivel como hobby. Gracias\n4\nK\n34\n#264\nscalvo\n#56\nquiero ese libro tanto como\n#147\n!\n0\nK\n10\n#163\npar\n*\n#40\ncreo que tienes que volver a clase de lenguajes de programación.\nYo no diría esto a alguien y después soltaría esto:\nC es un lenguaje de alto nivel, tan alto nivel como Java o Python.\nC no tiene nada que ver con Python. Es más, diria que se parece más al ensamblador que al Python.\nO cosas como:\nDicho esto, tu afirmación de que “cuanto más alto nivel más ineficiente” es evidente absurda y por ello falsa. La eficiencia del código depende mucho más de los conocimientos\n…\n» ver todo el comentario\n8\nK\n62\n#176\napetor\n#44\nNo no, ojo, que haya compiladores que permitan empotrar ensamblador o linkers que permitan enlazar con ficheros en ensamblador compilados en proyectos de C no quiere decir que C de acceso a ensamblador. C no tiene nada de eso. Por otra parte, SI, un poco por accidente y epoca de creacion y otro mucho por requisitos de la industria, C es\nTAMBIEN\nun ( o mejor dicho EL ) ensamblador portable en el sentido de que permite, precisamente, trabajar casi casi con el mismo nivel que la…\n» ver todo el comentario\n3\nK\n26\n#190\nfrankiegth\n*\n#44\n. '...\nLo que ejecute la CPU cuando programamos en C preocupa más bien poco. Se encarga el compilador de ello. Igual que en Rust\n...'\nEn lineas generales, pero cuando hablamos de programación de videojuegos lo que haga el compilador por su cuenta preocupa y ocupa. Esta misma noticia\n#0\nde algún modo lo confirma.\n1\nK\n23\n#20\nchavi\n#8\nC es un lenguaje de alto nivel. Se parece al ensamblador como un huevo a una castaña.\n22\nK\n137\n#38\nrepl_logos\n#20\nC es un ensamblador \"con colorines\". Lo jodido es que no estamos en una PDP11 y el estandar de C funciona como si lo fuera. Ni las CPUs hoy ejecutan un codigo amd64 puro.\n3\nK\n29\n#167\nfrankiegth\n*\n#40\n. \"...creo que tienes que volver a clase de lenguajes de programación...\"\nY yo creo que deberias estudiarte el 'código fuente' de un\ncompilador\nbásico de C, ya te adelanto que te sorprenderás de lo acertado de mi comentario\n#8\n.\n#38\n#20\n. Con colorines, una gráfica forma de plantearlo.\n#149\n. Efectivamente. Aparte de un compilador directo de lenguage ensamblador ningún otro lenguage está más cerca del propio ensamblador que el lenguage C, de ahí viene su eficiencia (bien empleado) y de ahí vienen los kernels de los sitemas operativos.\n4\nK\n45\n#280\nHemin\n#38\nsi, claro, y visual basic es un ensamblador \"en 3D\".\n1\nK\n18\n#40\neltoloco\n*\n#8\ncreo que tienes que volver a clase de lenguajes de programación.\nPrimero, como te ha dicho\n#20\n, C es un lenguaje de alto nivel, tan alto nivel como Java o Python.\nEs una confusión muy común pensar que hay distintos niveles de “altura” en la clasificación de los lenguajes de programación, cuando en realidad solo hay dos; bajo nivel (Lenguaje máquina y ensamblador) y alto nivel (Cualquier otro).\nTodo lo demás son charlatanería repetida mil veces por medios generalistas supuestamente…\n» ver todo el comentario\n5\nK\n44\n#48\nrepl_logos\n#40\n>cuando en realidad solo hay dos; bajo nivel (Lenguaje máquina y ensamblador) y alto nivel (Cualquier otro).\nEso en 1999. Hoy los procesadores desde amd64 no operan en registros directamente como pensarias. Hay microcodigo, y a efectos practicos segun el compilador (y no hablemos ya de cosas como el IR de LLVM) hacen que muchas veces el procesador opere de forma totalmente distinta a la que operaria un Z80 con instrucciones que se ejecutan de formal literal.\n5\nK\n39\n#65\nchavi\n#48\nEso en 1999.\nEso en 1999, en 2025 y en 2125.\nA no ser que le llames \"alto nivel\" a lo que a tí te salga de los cojones. ¿ Alguna vez en tu vida has visto algo codificado en ensamblador ?\nHoy los procesadores desde amd64 no operan en registros directamente como pensarias. Hay microcodigo,\nHay microcódigo desde hace eones. Los procesadores cableados son de usos muy específicos. Usamos CPU microprogramadas desde casi siempre.\ny a efectos practicos segun el\n…\n» ver todo el comentario\n3\nK\n29\n#66\nrepl_logos\n#65\n>¿ Alguna vez en tu vida has visto algo codificado en ensamblador ?\nSolo gameboy con su Z80 modificado, i486, amd64, risc-v... nada, poco.\n>Por otro lado si con LLVM te refieres a un entorno de ejecución de lenguaje intermedio al estilo Java, las CPU no ejecutan eso. El microcódigo no es para eso.\nNo.\n>Las instrucciones ensamblador siempre se ejecutan \"de forma literal\".\nYa no.\n3\nK\n21\n#68\nchavi\n*\n#66\nSolo gameboy con su Z80 modificado, i486, amd64, risc-v... nada, poco.\n¿ Y qué parecido le encuentras con un código escrito en C ?\nNo.\nNo qué ?\nA qué te refieres exactamente con \"IR\" y con \"LLVM\" hablando de ejecución de código ensamblador ??\nYa no.\nSi, A no ser que estemos entendiendo por \"forma literal\" cosas distintas. Una instrucción ensamblador hace lo que hace, no unas veces una cosa y otras veces otra. Si yo hago un MOV, un CMP un CALL, un JMP.... hace un MOV, un CMP un CALL o un JMP.\nPor cierto, leete el enlace a la Wikipedia que me has puesto. Te hace falta.\n1\nK\n23\n#181\npar\n#68\nUn MOV o un CMP quizás si que siempre se ejecuten igual, pero quizás una BEXTR (por decir algo), no. Y los pasos que el procesador va a seguir para ejecutarlo van a depender del microcódigo, que es lo que te están diciendo.\n(pd. No tengo ni idea de si la instruccion BEXTR se ejecuta usando microcodigo o no, solo la he usado como ejemplo).\n1\nK\n17\n#278\neltoloco\n*\n#48\n#174\n#181\n¿Alguna vez en vuestra vida habéis escrito una sola linea de código en C y en ensamblador?\nNo tienen absolutamente nada que ver, independientemente del juego de instrucciones que elijas para el ensamblador.\nEn ensamblador no hay ningún tipo de estructura de control, ni siquiera un simple condicional. Hay que hacerlo a manita con una comparación y un salto, CMP y JMP. Lo mismo para los bucles y cualquier otra estructura de control.\nDecir que son muy parecidos es demostrar desconocimiento total de lo que es la programación.\n2\nK\n32\n#51\nchavi\n#40\nLa eficiencia del código depende mucho más de los conocimientos del programador que del lenguaje elegido.\nY de la existencia y calidad del compilador\n6\nK\n57\n#77\ndiablos_maiq\n#40\nNop. Hay diferentes niveles en función de la distancia entre los conceptos que se manejan al enunciar los requisitos y los que se manejan al emplear el lenguaje e programación.\nA mayor nivel, menor distancia\n3\nK\n38\n#246\nchavi\n#77\nEntonces C++ es de mayor nivel que Rust..\n0\nK\n12\n#194\nTecar\n#40\nNo sé dónde habrás estudiado, pero con este discurso en mi clase no apruebas.\n0\nK\n7\n#205\nPortgasDAce\n#40\nbueno, C/C++, Zigg, Rust... Se suelen definir como me dio nivel porque te permiten (y obligan a) controlar la memoria (no tienen Garbage colector, Rust te permite controlarla de otra forma pero podríamos decir que \"sabes\" cuando va a reservarse, cuanta, cuando se liberará...).\nPero sí, todos son de alto nivel en el sentido de que la sintaxis y ordenes son las mismas, no varían con el hardware, abstrayendonos de pensar tan a bajo nivel (no controlas si se usa el set de instrucciones xx de los últimos procesadores, que caché está usando, ni nada de eso por ejemplo).\n3\nK\n32\n#149\nDragstat\n#8\n#20\ntenéis parte de razón los dos, y por eso C y C++ muchas veces se clasifican como lenguajes de nivel medio porque están más cerca del hardware y tienen menor nivel de abstracción que otros lenguajes, por ejemplo puedes manejar direcciones de memoria y registros. Preguntadle a Linus Torvalds si podéis tocarle el kernel de Linux en un lenguaje que no sea C a ver qué os dice.\n5\nK\n55\n#173\napetor\n#20\nmñeh, si y no, si pero no; y eso es una de las bazas de C, suficientemente alto para trabajar con el en orden y decoro/abstraccion, suficientemente bajo para ser el ensamblador portable y no ocultar la maquina a los que no queremos perder esa nocion de la maauina en ningun momento ( si, aun teniendo presente el modelo abstraido en todo momento; muchos creen que son excluyentes y para nada es asi ). De hecho C es aun mas que eso, C tiene un nivel de abstraccion variable, se puede variar segun el codigo que escribas... y todo sin forzar nada, de forma totalmente natural.\n3\nK\n38\n#174\nAMDK6III\n*\n#20\na ver, que un lenguaje ensamblador CISC x86/i686 no se parezca a C,\nno significa que C no sa parezca a lenguajes ensambladores de arquitecturas/instruction sets más limpios de tipo RISC .\nNo seamos tan categoricos , por favor. Vengo a Meneame a informarme y aprender, no a medir el tamaño de mi miembro viril con el de otros: eso no es una competición de quién sabe más.\nAsí que yo voto a favor de\n#8\n2\nK\n32\n#9\nLaro__\n#7\n...salvo que quieras hacer videojuegos...\n12\nK\n122\n#34\nrepl_logos\n#9\nO nuevos motores.\n1\nK\n19\n#103\nur_quan_master\n*\n#9\nexacto. Es como si me compro una sandía y digo que no es buena porque no vale para implementar juegos.\n1\nK\n23\n#6\nLaro__\nLa clave está aquí: \"el ecosistema de Rust carece de herramientas maduras comparables a las que ofrecen Unity o Unreal Engine\".\n12\nK\n106\n#7\nur_quan_master\n#6\ncomparar un lenguaje de programación con frameworks de videojuegos es como comparar peras con molletes.\n1\nK\n16\n#14\nPolarin\n#6\n0\nK\n9\n#35\nchavi\n#28\nPython se usa por su ecosistema, no por el propio lenguaje, que es bastante filfa, por cierto.\nAl que se le ocurrió el tema de los tabuladores había que fusilarlo.\n7\nK\n77\n#42\nrepl_logos\n#35\nEn eso estoy de acuerdo. Odio lo de los tabs, es un cancer a la hora de copiar o refactorizar codigo. Podian haber usado cualquier otro token.\n0\nK\n7\n#183\npar\n#35\nCuando dices tabuladores, te refieres a tabuladores y/o espacios, no?\n#42\nSabes que no tiene que ser tabs, no? Que problema encuentras al refactorizar código?\n0\nK\n6\n#72\ndiablos_maiq\n#35\n¿qué tema de los tabuladores?\n1\nK\n15\n#73\nchavi\n#72\nBorra uno en un sitio delicado. Guarda, coge el código al día siguiente y luego me cuentas\n0\nK\n12\n#80\ndiablos_maiq\n#73\ntambién puedo borrar una línea completa.\n¿Y?\n1\nK\n20\n#86\nchavi\n#80\nHombre, borrar una línea accidentalmente es bastante más difícil que hacerlo con un tabulador al inicio de una línea. No te parece?\nY ni siquiera el IDE te va a notificar nada.\n0\nK\n12\n#88\ndiablos_maiq\n*\n#86\nctrl-d en lugar de ctrl-s al salvar antes de cerrar. No es difícil.\n0\nK\n9\n#95\nchavi\n#88\nPara qué???\nEl código puede ser igual de válido sintácticamente con tab o sin tab.\nY puedes haber hecho muchos cambios después de borrar el tab accidentalmente.\n0\nK\n12\n#100\ndiablos_maiq\n*\n#95\nMencionaba un error fácil de cometer.\nY en cualquier lenguaje, una línea desaparecida puede dejar una sintaxis perfectamente válida.\nY uno puede seguir trabajando tranquilamente hasta que un día le explota el error en la cara.\n0\nK\n9\n#108\nchavi\n#100\nNo hablo de una línea. Hablo de un tabulador (que no se ve, una letra si se nota) al principio de una línea.\n0\nK\n12\n#150\neljuligallego\n#73\npara eso está el control de versiones\n0\nK\n9\n#170\nSupercinexin\n#35\nLos lenguajes son filfa, como Python, o no tienen futuro ,.como Rust, o super guachis, como C++, según a ti te parezca.\nPues okey. Con esos argumentos me queda definitivamente claro todo\n1\nK\n21\n#179\ndonchan\n#35\nMe ofrezco como tirador. Menuda cagada.\n0\nK\n7\n#3\nMetalAgm\nPara videojuegos y mucho más... C y C++ moderno.\n7\nK\n75\n#8\nfrankiegth\n*\n#1\n. El que no entiende de cortoplacismos en este caso es el propio hardware. Cuanto más alto es el nivel del lenguaje menos eficiente es respecto al hardware que lo ejecuta tras el compilado o tras el intérprete.\n#3\n. El C es practicamente ensamblador, alguien con mucha experiencia en C y ensamblador casi puede deducir que código fuente en ensamblador se va generando detrás del C, y el C++ una extensión orientada a objetos más lenta en cuanto al hardware y más rápida en cuando al desarrollo de software. Incluso es posible enfocar el lenguage C, sin objetos por defecto, orientándolo \"a mano\" a objetos.\n6\nK\n57\n#155\nmecha\n#8\ncomo alguien que empezó estudiando ingeniería informática aprendiendo C y ensamblador (gracias UGR), te digo que se parecen 0. Prueba a hacer el programa más simple del mundo y verás lo lejos que están.\nY te digo de paso, que ahora programo en C# la mayor parte del tiempo y puedo ver (y a veces lo hago por curiosidad) el código ensamblador que se ejecuta a partir de un código en C#. Si ves muchas veces esto puedes llegar a aprender que código ensamblador se va a generar. Lo cuál no quiere decir que ambos lenguajes estén cerca.\n(también veo muchos vídeos de Nick Chapsas y lo hace constantemente)\n2\nK\n20\n#186\nFooDev\n#8\n¿En qué momento C++ es más lento que C?\n0\nK\n6\n#242\nSr_Atomo\n#8\nCreo que se te ha borrado el \"OBOL\" que va justo después del \"C\".\n0\nK\n10\n#1\nCrudaVerdad\nHe escuchado que RUST es para desarrollos seguros pensando en el mediano y largo plazo. En un mundo de cortoplacistas, no va a funcionar.\n5\nK\n51\n#4\nFingolfin\n*\nCuanto más complejos sean los tipos, más acopladas van a estar diferentes partes del código, más complejas y frecuentes serán las refactorizaciones (una de las razones mencionadas en el código) y por tanto más difícil será hacer evolucionar el código. Un poco está bien, tipos estáticos de toda la vida, pero si ya empezamos a meter aspectos de memoria en los tipos se lia todo.\nToda esa complejidad añadida en los tipos tiene sentido cuando merezca la pena (es decir, cuando se necesite seguridad de memoria sin penalizaciones de GC u otras cosas), para el resto del mundo, un lenguaje con recolección de memoria es lo más sencillo y sensato.\nTodo el bombo y platillo que se da a rust está en gran medida injustificado\n5\nK\n46\n#10\nSupercinexin\n#4\nRust es bastante menos complicado de usar que C++, en varios órdenes de magnitud además. C++ es infumable.\nEl único problema aquí es que Rust es un lenguaje muy joven y no hay librerías maduras para un montón de cosas, como las que hay en C++, Java o Python.\nEl día que alguien desarrolle para Rust un motor de videojuegos, se acabó C++ porque quién va a querer hacer proyectos desde cero con un lenguaje mucho más complicado y que además es más inseguro. A igualdad de opciones Rust gana de calle.\nEn veinte años ni Cristo usará C ni C++ para proyectos que requieran lenguajes de bajo nivel. Ahora mismo esos lenguajes viven de la inercia de décadas de desarrollo de librerías, pero el futuro es claramente Rust.\n9\nK\n79\n#12\nCantro\n#10\neso decían cuando estaba en la carrera.\nQue COBOL era un cadáver esperando entierro y que c y c++ iban detrás\nUn visionario.\nTreinta años después ahí siguen\n13\nK\n97\n#13\nPolarin\n#12\n\"C++ es infumable\" solo porque no sabes usarlo bien. Yo no lo he usado profesionalmente porque me tuve que pasar a JAVA. Pero C++ es el culmen.\n\"Que COBOL era un cadáver esperando entierro y que C y C++ iban detrás\" Toda la infrastructura bancaria mundial funciona con COBOL en IBMs JCL. El dia que pasen toda esta mierda a algo mas moderno... como Kafka, .... dejan en la calle a miles de personas.\n1\nK\n20\n#59\nCantro\n#13\nel caso es que llevan cuarenta o cincuenta años jubilando a COBOL y el cabrón no se muere\nEs lo que me decían hace 30, cuando entraba en la carrera y ahí sigue, sin que se adivine en el horizonte una fecha en la cual se pueda decir \"pues adiós\".\n4\nK\n37\n#146\nluxaaar\n#59\npero no sigue por que se hagan nuevos desarrollos desde 0 con cobol, si no por que hay que mantener/expandir antiguos sistemas\n0\nK\n6\n#332\nPolarin\n#146\n#59\nY JCL con una IBM370 (version moderna)... . En banca es lo que hay en los backends. Vamos, que a mi me estan intentado llevar de vuelta a cuando tenia 20 y algo en mi curro... y como que no.\nCOBOL no muere, JCL y las IBM no mueren, pero nadie se quiere meter en eso porque nunca sabes cuando te vas a quedar sin curro. Algo tiene que sustiruirlo, Kafka + Hadoop o algo asi? Lo he visto usado para manejo de registros.\n0\nK\n9\n#192\ninovercy\n#13\nC++ mola, pero bien es cierto que Rust es más sencillo cuando no tienes sesgos.\nA mi me costó un poco aprenderlo, porque todo el tema de los lifetimes, y como funcionan las referencias a memoria, con su sistema de propiedad se me hacía raro. Pero una vez que lo aprendes, dominarlos es menos complicado porque pegarte un tiro en el pie es mucho más difícil. Con C++ tienes más posibilidades de liarla con accesos a memoria, etc.\n2\nK\n29\n#16\nSupercinexin\n#12\n¿Qué siguen dónde? COBOL es un cadáver, nadie en el mundo empieza proyectos en ese lenguaje en ningún sitio y para nada. Existe en lugares donde ya estaba implementado y una migración no es conveniente y ya está, eso es todo.\nC y C++ son otros dos que ya están empezando a ser despreciados también. Todas las herramientas de sistemas o los nuevos paradigmas y aplicaciones se están implementando en Rust o en Go, una de dos. C++ sólo sobrevive en lugares donde no hay librerías disponibles para esos menesteres, como por ejemplo los videojuegos, pero ya está. En cuanto a la inteligencia artificial, prácticamente dominada hoy en día por Python, es cuestión de tiempo que Rust empiece a desplegarse en todo el bajo nivel, reemplazando a C++.\n1\nK\n24\n#17\nrepl_logos\n#10\nEn las consolas la seguridad importa una mierda.\n#16\nPython sin C, C++ y BLAS/LAPACK (fortran) estaria muerto.\n3\nK\n32\n#22\nSupercinexin\n#17\nNo se refiere a la seguridad de que un tío entre y te robe los datos. En Rust, cuando hablan de seguridad, se refieren a que no te explote en la cara un puntero a NULL en tiempo de ejecución, cosa que por diseño en Rust es imposible.\nPython tiene cien mil librerías que se gastan masivamente y que no tienen implementaciones internas de bajo nivel y por lo tanto no gastan C's ni FORTRANs. En cuanto a las que lo hacen, Rust está ya, ahora mismo, sustituyendo a C y C++ en esas librerías Python, por motivos más que evidentes.\n1\nK\n21\n#29\nrepl_logos\n#22\nBuena suerte con Rust intentando reemplazar a BLAS/Lapack. Lo mismo en videojuegos de consolas donde la seguridad no impote. Si, accesos a memoria y toda la hostia. Pero hay fuzzers, valgrind y 10000 herramientas para evitar eso al menos en plataformas no de uso general como juegos en primera persona. Un navegador ya es otra cosa; y un así chromium en openbsd con unveil/pledge junto con su sandbox es mas seguro que Firefox con Rust.\n0\nK\n7\n#165\nSupercinexin\n#29\nY dale con \"la seguridad no importe\". Que no estamos hablando de \"seguridad de hackers robándote los datos\", que estamos hablando de que el programa pete por cualquier lado con punteros a NULL y errores jodidísimos de depurar y de arreglar que finalmente ves en tiempo de ejecución cuando tú querida aplicación en C++ ha llegado ya al cliente final. Esa es la seguridad que ofrece Rust, que ni C ni C++ jamás podrán ofrecer. Para eso se creó Rust y ahí radica toda su fuerza.\n#32\nMódulos que están ahora mismo, hoy, y en 2024 y en 2023 y en 2020 también estaban ya, cada vez más desarrollándose en Rust.\n2\nK\n32\n#32\nchavi\n#22\nEl triunfo de Python se debe en gran medida a la facilidad de creación de módulos en C.\n0\nK\n12\n#164\nSr.No\n*\n#17\nPython, al ser interpretado, utiliza un interprete que puede estar escrito en diferentes lenguajes, de ahí que tengamos:\n* CPython, el más estándar,\n* JPython, sobre Java. En entornos Hadoop se ve bastante por temas de Scala.\n* PyPy,\n* RustPy,\n* etc...\nY una larga lista. Evidentemente, el interprete subyacente afecta a las capacidades y rendimiento de Python, pero aun así hay para elegir según la aplicación.\n0\nK\n10\n#18\nrepl_logos\n#16\n>C++ sólo sobrevive en lugares donde no hay librerías disponibles para esos menesteres, como por ejemplo los videojuegos, pero ya está\nYa quisieras. En videojuegos de PC y consola, multimedia, navegadores... es el rey.\n0\nK\n7\n#26\nur_quan_master\n#18\ninfinidad de librerías que usa python están implementadas en c o c++\n2\nK\n25\n#55\nrepl_logos\n#26\nY Fortan para algebra/calculo numerico.\n0\nK\n7\n#168\nSupercinexin\n#18\nEn videojuegos es donde más librerías base hacen falta y donde esas herramientas en Rust aún no están desarrolladas. En todo lo demás, sistemas, IA, navegadores como tú dices... Ni Cristo empieza un proyecto nuevo en C ni en C++. Actualízate.\n0\nK\n10\n#23\nchavi\n#16\nC sigue siendo el lenguaje de sistemas por excelencia.\nWindows o Linux usan C.\n1\nK\n21\n#36\nrepl_logos\n#23\nWindows es C++. Pero hablar de C es hablar de LA API de Unix, prototipos, estandares IEEE y el lenguaje que esta en todas partes, hasta en teleco . Es como hablar de ingles en negocios, ciencia y tecnologia. Toda la nueva terminologia y aparatos/estandares es en ingles.\n2\nK\n27\n#39\nchavi\n#36\nBueno, C/C++.\nC++ tiene la posibilidad de usar entremezclado codigo C.\n0\nK\n12\n#45\nrepl_logos\n#39\nNo, no es lo mismo, han divergido muchisimo, nada que ver.\n0\nK\n7\n#46\nchavi\n#45\nNo he dicho que sean lo mismo. Digo que es común usar código C desde C++, el lenguaje incorpora facilidades para ello.\n0\nK\n12\n#189\napetor\n#36\nWindows es C, no C++, C.\n0\nK\n9\n#41\nselina_kyle\n*\n#16\nen intérprete de Python está escrito en C. Creo que el de Java y JavaScript también. Hasta que no se pueda compilar Python a binario directamente, C y C++ seguirán siendo indispensables.\n1\nK\n19\n#184\npar\n*\n#41\nHasta que no se pueda compilar Python a binario directamente, C y C++ seguirán siendo indispensables.\nPor qué, exactamente?\n0\nK\n6\n#182\napetor\n*\n#16\nYa, buena suerte para la infrastructura de base de cualquier nuevo hardware fuera de C. Rust... bueeeno, pero Go ? sorry, no. C es un standard de la industria, va mas alla del lenguaje en si.\n0\nK\n9\n#15\nFingolfin\n*\n#10\n¿Quien ha hablado de C++? Por lo demás, Rust sólo puede presumir de sencillez comparandose con C++, porque no es un lenguaje nada sencillo por si mismo (y no dejan de complicarlo para tratar de paliar las desventajas que tiene su modelo, en lugar de aceptar que no tiene por qué servir para todo... )\nEn principio dudo que alguien escriba un gran motor de juegos en Rust. El modelo de Rust implica a menudo hacer copias,no es precisamente lo ideal cuando se quiere exprimir al máximo el…\n» ver todo el comentario\n2\nK\n32\n#19\nSupercinexin\n#15\nBueno, también se decía que Python era una mierda y que por su diseño y sus características jamás sería usado para nada fuera de scripts sencillos. Hoy se usa para todo el análisis de datos y toda la IA. Igualmente Rust está sustituyendo a C y C++ en la implementación a bajo nivel, por debajo de Python, a muchas de esas herramientas de análisis de datos con un seguridad muy superior en tiempo de ejecución y con un rendimiento increíble que en no pocos casos supera a sus contrapartes en…\n» ver todo el comentario\n0\nK\n10\n#25\nFingolfin\n*\n#19\nYa hay lenguajes alternativos a Rust, y no dejan de crearse nuevos lenguajes cada año, no vas a tener que esperar a 2050. Es ridículo pensar que si la seguridad de memoria es un requisito, Rust va a ser el único lenguaje que lo implemente y nadie más va a hacerlo\n0\nK\n11\n#28\nSupercinexin\n#25\nTambién hay lenguajes alternativos a Python. Cuando se usen una milésima parte de lo que se usa Python, hablamos. Cuando esos lenguajes que supuestamente se están creando para solucionar los problemas de Rust se usen en cualquier sitio mínimamente relevante, como un navegador web o un sistema de orquestación de contenedores, hablamos.\nHay dos tipos de lenguajes de programación: los que la gente odia y los que nadie usa. C, C++, Rust, Python, Java y Go son odiados y el resto no los usa nadie\n0\nK\n10\n#273\nLaro__\n#28\nHas olvidado C# y javascript; 5º y 6º en el índice TIOBE... que lo sepas.\n1\nK\n21\n#101\nrepl_logos\n#25\nYa existian ADA/Spark y MISRA C que poco tienen que envidiarle a Rust.\n1\nK\n18\n#33\nchavi\n*\n#19\ncon un seguridad muy superior en tiempo de ejecución\nUn programa bien hecho en C es exactamente igual de seguro que uno bien hecho en Rust.\n¿ A qué le llamas tú \"guarrear\" ?\n0\nK\n12\n#43\nrepl_logos\n#33\n> Un programa bien hecho en C es exactamente igual de seguro que uno bien hecho en Rust.\nNo, lo siento, y eso que no me gusta Rust, pero Rust es mucho mas seguro que C en ese aspecto. Si hubieras dicho C++...\n2\nK\n28\n#47\nchavi\n#43\n¿?\nEn qué es \"mas inseguro\" exactamente?\nRecuerda que hablamos de programas bien hechos. No es una cuestión de gustos.\nSi hubieras dicho C++...\nC++ no es \"más seguro\" que C. El acceso a memoria es prácticamente igual.\n0\nK\n12\n#49\nrepl_logos\n#47\nC++ tiene rutinas de manejo automatico de memoria. C, no, a no ser que uses o bien una libreria o cosas com BoehmGC.\n0\nK\n7\n#57\nchavi\n#49\nC++ tiene rutinas de manejo automatico de memoria\nHombre, hace tiempo que no uso C++ pero supongo que hay cosas que no han cambiado:\nSi defino un puntero, puedo usarlo sin inicializarlo. Es C y C++. También puedo cambiar la dirección a la que apuntan sin restricciones...\nO puedo no liberar nunca memoria reservada (new o malloc)\n¿ Sigue siendo así ?\nporque básicamente cuando dicen que es un \"sistema inseguro\" se refieren a eso.\n0\nK\n12\n#60\nrepl_logos\n*\n#57\nC++ ha cambiado mucho en 20 años. Tengo roguelikes desde el 2007 (no desde 1997) que no compilan con los GCC o clang de hoy. Ni de la rama 10, y la 8.4 a duras penas. Creo que debo usar GCC 4.8 para poder compilarlos.\nDesde hace 10 años o así salvo programadores de videojuegos o cosas como FFMPEG nadie gestiona la memoria a mano en C++...\n0\nK\n7\n#61\nchavi\n#60\nLa pregunta no es cuanto ha cambiado C++, sé que lo ha hecho.\nPero si siguen permitiéndose esas cosas que he indicado (y espero que sí) sigue siendo igual de inseguro. Que hayan incorporado medios para gestionar de otro modo la memoria no cambia nada.\nYo mismo he usado sistemas diseñados para lo mismo (como si fueran \"microframework\") en C... a costa de cierto rendimiento, claro.\n0\nK\n12\n#213\nMetalAgm\n#57\nC++ moderno ha incluido infinidad de cosas de seguridad y alto nivel como smart pointers (unique_ptr, shared_ptr) o funciones lambda y muchas cosas más... dale un repaso al nuevo C++...\nYa no necesitas hacer new y delete... simplemente haces std::make_unique o std::make_shared y tienes el objeto creado en memoria dinámica igual que si hicieras new o malloc y encima no tienes que hacer delete, el smart pointer se encarga de liberar la memoria por ti si se te pasa borrarla...\n0\nK\n11\n#70\nspacos\n#47\nEl ser humano es imperfecto, por mucho que tu quieras hacer algo perfecto, fallaras miserablemente. Eso significa que se necesita de herramientas que te automaticen la seguridad y fiabilidad porque por mucho que tu quieras ser el mas mejor de los programadores, la cagaras, incluso sin darte cuenta.\n0\nK\n6\n#76\nchavi\n*\n#70\nPara eso están los test y las revisiones. Lo que se pretende es descargar la responsabilidad del programador en el lenguaje y eso a mí entender es desastroso.\nEso sí, eso permite aumentar la presión de entrega,reducir los test y producir código funcional más rápido. Código de mierda, pero funcional.\nRust es una buena idea para grandes empresas de sistemas. Si se dispone de tiempo y no hay presión, C sirve.\n0\nK\n12\n#83\nspacos\n#76\nCoincido, pero personalmente no tocaria c/c++ para nada hoy en dia si no es codigo legacy. Si tuviera que hacer algo nuevo usaria go/Rust/c# o algun otro con automatizaciones de seguridad.\n2\nK\n28\n#91\nchavi\n#83\nMe parece lógico.\nPero citar ahí a C# es como poner Java. Es un lenguaje \"para otra cosa\".\n0\nK\n12\n#191\napetor\n#83\nRust tiene la posibilidad ( aunque muy burda y antinaturalmente y jodiendo mas que ayudar ), pero intenta hacer algo de sistemas con esos lenguajes...\nEjemplo:\nwww.youtube.com/watch?v=kKZfGYvQ9kg\nEn este caso este software se ejecuta en paralelo y engarzado primero con la UEFI del sistema y luego con Windows 11 ( y su kernel NT ), ya no hablamos de un programa con su comienzo y final, monolitico,...\nNo quiero darmelas de nada pero... para sistemas, lo serio, C y ensamblador.\n0\nK\n9\n#195\ninovercy\n#47\nEn su diseño es más inseguro. Rust, por diseño no permite tener punteros a NULL, tampoco permite tener multiples referencias mutables a la misma posición de memoria.\nPuedes hacerlo con C++? Por supuesto, puedes usar uno de los últimos estandar, creo que desde C++11 ya tienes smart pointers, por ejemplo. Pero dependes de que el programador con el que trabajas tenga una buena forma de trabajar. No todo depende de que tú seas bueno, depende de que el equipo sea consistente con la seguridad.…\n» ver todo el comentario\n0\nK\n9\n#169\ndonchan\n#19\nEstá ZIG. Quizás demasiado nuevo. Te ofrece casi lo mismo que RUST pero sin la protección de memoria, lo que da mucha más libertad para hacerlo como quieras.\nTiene un fuerte enfoque en no tener cosas ocultas, para que sea fácil saber qué significa lo que lees. Eso le quita alguna funcionalidad.\n0\nK\n7\n#21\nchavi\n#10\nEs que Rust no es orientado a objetos. No tiene sentido compararlo con C++.\nLa comparación es con C\n1\nK\n15\n#24\nSupercinexin\n#21\n¿Y qué que no sea orientado a objetos? Rust es el sustituto de C++, efectivamente. El sustituto de C es Go.\n0\nK\n10\n#27\nchavi\n#24\nComo que \"y qué\"???\nSabes lo que aporta la orientación a objetos a la hora de desarrollar ???\nRust podría sustituir en todo caso a C. Jamás a C++.\nY realmente los leak de memoria se deben a las prisas o incompetencia de los programadores. Querer arreglar eso vía lenguaje de programación no me parece buena idea.\n0\nK\n12\n#30\nSupercinexin\n#27\nRust podría sustituir en todo caso a C. Jamás a C++\nlos leak de memoria se deben a las prisas o incompetencia de los programadores. Querer arreglar eso vía lenguaje de programación no me parece buena idea.\n0\nK\n10\n#37\nchavi\n*\n#30\nBuenos argumentos....\nSe nota que eres un gran programador..... que jamás ha escrito una línea en condiciones.\nExplicame que es eso de \"un lenguaje inseguro\".... si eres capaz....\n0\nK\n12\n#52\nselina_kyle\n#37\ntienes 10 años?\n0\nK\n9\n#53\nchavi\n#52\nNo mejoran tus argumentos.... prueba otra vez.\nSi no estás de acuerdo con lo que he afirmado será por algo más que por\n, digo yo...\nTu si que no debes tener ni 10 años...\n0\nK\n12\n#175\nSupercinexin\n#37\nNo había leído éste comentario antes.\nBuenos argumentos.\nBuenos son los que tú das: \"Rust no puede sustituir a C++, sólo a C\", \"Python es una filfa de lenguaje\", \"los leaks de memoria en C y C++ es porque los programadores son incompetentes\".\nTodo porque lo dices tú. Qué sabrán los demás.\nSe nota que eres un gran programador..... que jamás ha escrito una línea en condiciones.\nYa veo el tipo de programador que eres tú. Sin comentarios.\n2\nK\n35\n#208\nReview\n#27\nMe estoy leyendo la discusión que lleváis, y quería entrar en éste comentario que no me ha gustado cómo te han contestado en\n#30\n:\nRust podría sustituir en todo caso a C. Jamás a C++\nRealmente aunque Rust no sea OOP es tan capaz o más para desarrollar lo mismo que un programa hecho en C++, y de estructurarlo de manera muy similar. Evidentemente cada lenguaje tiene que tener la implementación hecha a su manera, no puedes copiar la estructura de un programa hecho en Javascript y…\n» ver todo el comentario\n1\nK\n16\n#74\nspacos\n#27\nLa programación orientada a objetos es solo un paradigma de programación mas, de entre tantos otros. Los lenguajes funcionales, por ejemplo, no suelen usar la programación orientada a objetos y son excelentes a la hora de desarrollar software. De hecho, hoy dia la programación orientada a objetos se considera algo desfasada y no recomendable para según que cosas. Quiero decir que Rust puede perfectamente sustituir a C++ sin problemas aunque no soporte ese paradigma de programación.\n0\nK\n6\n#82\nchavi\n#74\nLa programación orientada a objetos es solo un paradigma de programación mas\nClaro. Uno que ofrece grandes ventajas en muchos ámbitos. Por eso es la más usada.\n. Los lenguajes funcionales, por ejemplo, no suelen usar la programación orientada a objetos\nCasi todos los lenguajes oop tienen características que permiten cierto grado de programación funcional como las lambda\nDe hecho, hoy dia la programación orientada a objetos se considera algo desfasada\n????\nQuién la…\n» ver todo el comentario\n1\nK\n23\n#90\nrepl_logos\n#82\n>ierto grado de programación funcional como las lambda\nLos lambda de Python comprados con CL o Scheme son un chiste.\n0\nK\n7\n#94\nchavi\n#90\nEs que ni Python, ni C++ ni Java pretenden ser Scheme.\nPor eso son usados en muchos ámbitos y Scheme no.\n0\nK\n12\n#96\nrepl_logos\n#94\nScheme en GUIX en Inria FR como lenguaje tanto de la distro como de los programas para configurarla. Common Lisp se usa en sitios donde te pagan en un mes lo que en 12 en España. Son altamente especializados, y por desgracia con Allegro CL o LispWorks, pero todo dios usa SBCL para prototipos donde tiene un alto rendimiento pese a ser libre y no tener tanto apoyo comercial.\n0\nK\n7\n#104\nchavi\n#96\nBuena mezcla de paradigmas. Bien traído lo de Lisp.\nMe gustaría verte desarrollar un programa de gestión con eso...\nLos paradigmas tienen ámbitos de aplicación. Hay paradigmas más generales y paradigmas más específicos\n0\nK\n12\n#99\nrepl_logos\n#94\nwww.grammarly.com/blog/engineering/running-lisp-in-production/\nY tengo mas articulos por ahi. Son entornos poco de juguete, donde se exige una correctitud bestial y cosas que tardas un mes en CL tardas en C++ meses o si no anyos. De Python olvidate.\n0\nK\n7\n#107\nchavi\n*\n#99\nJoder, Lisp.....\nAhora programa la gestión de un hotel con eso....\nLos paradigmas tienen ámbitos de aplicación. Y los hay que se adaptan más a distintos ámbitos y los que se adaptan menos.\n0\nK\n12\n#207\ndonchan\n#90\nLa referencia siempre es Haskell\n0\nK\n7\n#93\nspacos\n#82\nLa programacion funcional esta cada vez mas implantada, de hecho cada vez mas lenguajes implementan paradigmas de la programacion funcional en detrimento de la programacion orientada a objetos. El hecho de los tipos inmutables es un ejemplo. Mi lenguaje de programacion favorito y en el que desarrollo gran parte de mi codigo es Elixir que no tiene nada de objetos a la vista y es una pura delicia programar en él. Que la gente no use Haskell te lo puedo comprar si te refieres a eso. La…\n» ver todo el comentario\n1\nK\n18\n#102\nchavi\n#93\ncada vez mas lenguajes implementan paradigmas de la programacion funcional en detrimento de la programacion orientada a objetos.\nCada vez más lenguajes implementan paradigmas funcionales (es lo que he dicho antes), pero en detrimento de nada.\nNingún lenguaje ha perdido ninguna característica OOP por ello.\nA qué te refieres con \"tipos inmutables\"??\nLa programacion orientada a objetos hoy dia se considera casi obsoleta\nQuién lo considera obsoleto y por qué ??\nDiseña un programa de gestión sin OOP y me cuentas.\nC se considera obsoleto\nQuién lo considera obsoleto y basándose en qué??\n1\nK\n21\n#156\nOvlak\n#93\nLa programacion orientada a objetos hoy dia se considera casi obsoleta\nSólo puedes estar trolleando con semejante afirmación. No hay ninguna otra opción.\n2\nK\n26\n#198\ninovercy\n#27\nPuedes desarrollar lo de que no podría sustituir a C++ porque no es orientado a objetos?\nPorque en Rust puedes montar structs (como en C, si), e implementarlos con partes publicas y privadas, creando Traits para permitir a otros implementar ciertas funcionalidades, que bien podrían valer para hacer gran parte de lo que se hace en C++.\nSobre que los leak son por prisas o incompetencia. Si, claro, y eso es parte del mundo en el que vivimos, la gente la caga. Programando, conduciendo, pilotando, diagnosticando. Y si hay tecnología que puede reducir errores programando para tener menos bugs, conduciendo para tener menos muertos, o diagnosticando para pillar enfermedades antes, lo lógico es que se usen dichas herramientas.\n0\nK\n9\n#31\nchavi\n*\n#10\nC++ es infumable.\nNo. C++ no es infumable. Otra cosa es la curva de aprendizaje si no vienes de C.\nC++ es \"el lenguaje\".\nEl único problema aquí es que Rust es un lenguaje muy joven\nEl no ser orientado a objetos es un handicap enorme para convertirse en un lenguaje de desarrollo general. Compararlo con C++, Java o Python es un error. La comparación debe hacerse exclusivamente con C.\nse acabó C++ porque quién va a querer hacer proyectos desde cero con un\n…\n» ver todo el comentario\n2\nK\n25\n#79\nspacos\n#31\nPor ahi ya lo he dicho. Es de novatos creer que los programadores son seres de luz que nunca se equivocan y que con el suficiente esfuerzo el codigo en c/c++ sera exquisito. Eso es una chorrada de principiante. Primero, muchas veces cometes errores de los que no te das cuenta,muchas veces el lenguaje no tiene las herramientas para asegurarte que lo que has escrito esta bien. Segundo, la gente es gente, y cualquiera que haya programado mas de 100 lineas de codigo sabe que los proyectos…\n» ver todo el comentario\n2\nK\n20\n#89\nchavi\n*\n#79\nPor eso el hecho de que la seguridad este incrustada en el propio lenguaje es esencial para escribir mejor codigo\nDisiento.\nY la experiencia demuestra que entre \"más seguro\" es el lenguaje, más mierda es el código.\nY peor aún, se pierden los buenos hábitos y se cogen vicios muy difícilmente corregibles.\nEl desplazar la seguridad al código puede hacer ahorrar dinero a la empresa, pero no lleva a código de más calidad. Todo lo contrario\nSe perfectamente en qué consisten los fallos de gestión de memoria en C. Estoy cansado de pelearme con ellos.\nPor eso es muy muy muy raro que los cometa. Pongo exquisito cuidado\n0\nK\n12\n#98\nspacos\n#89\nCada uno tiene su opinion, pero mi experiencia me dice que un programador a las 12 de la noche con ojeras y fuego en los ojos depues de un par de dias de curro intenso no estara para exquisiteces. Yo prefiero que la herramienta por construccion no me deje hacer chorradas, pero cada cual tiene su librillo...\n0\nK\n6\n#106\nchavi\n#98\nYo prefiero dormir.\nEl lenguaje no evitará que hagas chorradas en esas condiciones.\nEso sí, los errores con los punteros son infernales. Pocas bromas\n0\nK\n12\n#54\nrepl_logos\n#10\nEn veinte años igual usamos GNU/Hurd con hordas de demonios sobre un microkernel importando poco Rust ya que podras reiniciar los drivers de casi todo al vuelo y podras como usuario sin privilegios desde montar discos a hacer virguerias que hoy solo se logran con permisos de grupos.\n1\nK\n10\n#63\nchavi\n*\n#54\nya que podras reiniciar los drivers de casi todo al vuelo y podras como usuario sin privilegios desde montar discos a hacer virguerias que hoy solo se logran con permisos de grupos.\n¿?\nSi se requieren permisos para algo es por una razón. No \"por accidente\". La necesidad de permisos para cualquier acción sobre el sistema no tiene nada que ver con el lenguaje con que esté implementado ese sistema ni con la arquitectura de su kernel.\n0\nK\n12\n#64\nrepl_logos\n#63\nHurd es diferente. No necesita permisos de root para montar discos, ni para usar cosas analogas a FUSE en Linux por ejemplo para montar directorios remotos.\nUsa espacios de nombre, cosa que tambien puedes ver en plan9. Nada que ver con un Unix clasico.\n0\nK\n7\n#67\nchavi\n#64\nHurd es diferente.\nEn este aspecto no. No es diferente. Ni debe serlo.\nNo necesita permisos de root para montar discos,\nNi yo con GNU/Linux. En todo caso es una decisión de diseño del SO (una mala. debe poder restringirse el montaje)\nni para usar cosas analogas a FUSE\n¿ Como cual ?\nFUSE simplemente es un sistema de montaje a nivel de usuario.\npara montar directorios remotos\nEso no tiene nada que ver con HURD. Tiene que ver con samba, nfs, ssh, iscsi.....\nUsa espacios de nombre\nVaya, como GNU/Linux. O como crees que funciona LXC o Docker ?\nCreo que no entiendes mucho de lo que hablas....\n0\nK\n12\n#69\nrepl_logos\n#67\nEntiendo de sobra, el que no entiende eres tu. Los namespaces en Linux son un parche; en 9front y Hurd son intrinsecos. En Hurd puedes montar discos sin permisos sin parches cutre como FUSE o hacer virguerias con los namespaces puestos ad-hoc.\nSi es diferente, y no has tocado una distro hurd un tu vida. Prueba a montar un FTP sin fuse y sin root en GNU o BSD y me comentas. Con hurd se puede con ftpfs ya que el propio diseño basado en servicios hace que los usuarios puedan tener sus propios directorios de montaje sin joder al resto.\n0\nK\n7\n#78\nchavi\n#69\nNo uso FTP desde hace eones. Y no veo el problema de usar fuse.\nPor cierto eso de ftpfs suena a sshfs\n0\nK\n12\n#85\nrepl_logos\n#78\nsshfs que depende de FUSE y mas permisos.\n0\nK\n7\n#92\nchavi\n#85\nQue \"más permisos\" ?\nYo lo uso y ya.\n0\nK\n12\n#71\nrepl_logos\n*\n#67\nwww.gnu.org/software/hurd/hurd/settrans.html\nwww.gnu.org/software/hurd/hurd/translator.html\nIgualito que Linux o cualquier BSD con perms basados ya sea en grupos o en abortos como polkit, si, no veas.\n0\nK\n7\n#75\nchavi\n#71\nQuien ha dicho que \"sea igual\".\nEn Linux yo.puedo montar lo que me de la gana siendo un simple usuario, o no. Según decida.\nEspero que con Hurd sea igual... (Y lo será)\n0\nK\n12\n#81\nrepl_logos\n#75\nSimple usuario; no. Usuario perteneciendo a un grupo y antes con parches cutres como SUID. En Hurd no es como accedes a tus recursos. Por no haber no hay ni simlinks, si no operaciones con bind que permiten muchisimo mas que con un clonico GNU o BSD.\n0\nK\n7\n#84\nchavi\n*\n#81\nSi. Simple usuario y sin suid ni siquiera fuse.\nEl tema de gestión de permisos es una simple cuestión de diseño del sistema. Nada más.\nNo tiene que ver con qué sea microkernel o no\n0\nK\n12\n#87\nrepl_logos\n*\n#84\nUsa FUSE:\nwiki.archlinux.org/title/SSHFS\nAhora comparalo con 9p en 9front y demas y tu cifrado al gusto encima.\n> No tiene que ver con qué sea microkernel o no\nEn Hurd los demonios importan.\n0\nK\n7\n#97\nchavi\n#87\nY qué que use FUSE ?\nAdemás no entiendo el cambio de juego....\nNo estamos debatiendo sobre microkernel y kernels monolíticos.\nCuando Hurd sea verdaderamente funcional podremos hacer comparaciones fundamentadas\n0\nK\n12\n#180\napetor\n#10\nC++, si pasas de cosas muy viejas y te fuerzas incluso a un subset del lenguaje ( ojo, esto incluye cosas normales como sobrecarga de operadores, excepciones,... ) es mas sencillo que Rust y otros. Y por cierto, Rust tiene mucho codigo de libreria, pero en la practica, no engañan a nadie, eso NO SON LIBRERIAS, hay que recompilar fuente siempre. Y claro, diran que ya estan en ello ( persiguiendo un \"ABI\" interno que tenga todos los metadatos necesarios para que se pueda linkar en…\n» ver todo el comentario\n0\nK\n9\n#210\nReview\n#10\nEl día que alguien desarrolle para Rust un motor de videojuegos, se acabó C++\nYa hay motores de videojuegos desarrollados en Rust, pero creo que se está perdiendo el foco en la discusión en general respecto al lenguaje a utilizar para hacer videojuegos y el lenguaje del motor.\nGodot está hecho en C/C++ pero puedes programar para él en muchos lenguajes, entre ellos Rust. El problema que no veo que nadie menciona es que para qué usar un lenguaje u otro.\nA nivel de aficionado he…\n» ver todo el comentario\n0\nK\n6\n#5\nLeclercia_adecarboxylata\nWipp express parecía el quitamanchas ideal para la ropa delicada. Esta familia acabó abandonándolo tras tres años centrado en él.\n4\nK\n23\n#11\nRaúl_Rattlehead\nLo del uso de imágenes generadas por IA de cosas tan básicas es ya por joder, seguro que era súper difícil y costoso encontrar una foto de una persona usando el ordenador.\n2\nK\n21\n#162\nXQNO\n#11\nXataka tiene como 40 portales temáticos, mucho de ellos centrados en tecnología, y lleva más de 20 años publicando a diario decenas de noticias ilustradas con \"una persona usando un ordenador\". La vedad es que tener a un ilustrador creando imágenes especificas para cada articulo con herramientas con IA, en vez de rebuscando novedades en bancos de imágenes tiene bastante sentido. Otra cosa es que a ti no te guste, por motivos político o éticos, que nadie use herramientas con IA y pienses que la gente los usa \"por joder\".\n0\nK\n9\n#2\nFindeton\nNosotros usamos rust en el backend, pero entiendo perfectamente que no se use para videojuegos donde prima la eficiencia y flexibilidad sobre la seguridad.\n1\nK\n17\n#241\nBuckMulligan\n#2\nNo he programado mucho en rust, pero ¿no se pordría solucionar lo que dice el artículo usando rust en unsafe mode para los prototipos?\n0\nK\n10\n#212\nchavi\n#183\nSi. Tabuladores y o espacios. Un tabulador no es más que una \"abreviatura\" de un conjunto de espacios contiguos\n0\nK\n12\n#360\nrepl_logos\n#212\nUn tabulador es un carácter, \\t. Lo que hagan los editores es otra cosa.\n0\nK\n7\n«\n1\n2\n3\n4\n»\nVer toda la conversación (\n360\ncomentarios)\nAutentifícate si deseas escribir\ncomentarios. O crea tu cuenta\naquí.\nLogin con Twitter\nLogin con Facebook\nLogin con Google\nmenéame\ncondiciones legales\n/\nde uso\n/\ny de cookies\n/\nquiénes somos\n/ licencias:\ncódigo\n,\ngráficos\n,\ncontenido\n/\nHTML5\n/\ncodigo fuente",
  "highlightText": "",
  "highlightTitle": "",
  "highlightThreadTitle": "",
  "language": "spanish",
  "sentiment": "negative",
  "categories": [
    "Science and Technology",
    "Economy, Business and Finance"
  ],
  "topics": [
    "Science and Technology->technology and engineering"
  ],
  "ai_allow": true,
  "has_canonical": false,
  "breaking": null,
  "webz_reporter": false,
  "external_links": [],
  "external_images": [],
  "entities": {
    "persons": [],
    "organizations": [],
    "locations": []
  },
  "syndication": {
    "syndicated": null,
    "syndicate_id": null,
    "first_syndicated": false
  },
  "rating": null,
  "crawled": "2025-01-10T03:06:51.140+02:00",
  "updated": "2025-01-10T03:06:51.140+02:00"
}